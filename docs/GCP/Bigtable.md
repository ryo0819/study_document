# 概要
- `ペタバイト規模のフルマネージドNoSQLデータベース`
- 大量のデータのインデックス作成、クエリ、分析が可能
- 低レイテンシーで大量のシングルキーデータを格納するのに最適
- 低レイテンシーで読み取り・書き込みに対し、高いスループットをサポートしている
- 以下のようなデータを扱うのに適している
    - 時系列データ
    - マーケティング
    - 金融
    - IoT
    - グラフ
    - メッセージング

## 詳細
- 開発環境から本番環境に変換する`インプレススケーリング`が可能

- ホットスポット(書き込みが多発・ボトルネックの箇所)の特定には`key visualizer`を使用する
    データ量の多い行・テーブルの行全体がバランス良くアクセスされているかもわかる

- 最大の`書き込み`スループット
    1. カーディナリティ値が高いものを行キーの先頭にする
        - 連続した書き込みが単一ノードにプッシュされずにホットスポットが起こらない
    1. アクセスパターンに基づき、行キーに全ての属性を保持する

- 最大の`読み込み`スループット
    1. 単一ノードから読み込まれるので、ホットスポットを作成するようにカーディナリティ値が低いものを先頭にする
    1. アクセスパターンに基づき、行キーに全ての属性を保持する

- セカンダリインデックスはなく、各行キーは一意の必要がある

- cbtツール
    BigTableでさまざまなオペレーションを行うためのコマンドラインターフェース(Go言語)

- レプリケーションは結果整合性がある
    - 1つのクラスタに変更を書き込むと、他のクラスタから読み取れる
    - レプリケートされた後に限る(書き込みを数秒待てば解消されるわけではない)

- 強整合の実現にはアプリケーションプロファイルの使用&インスタンスの単一のクラスタにクエリ制限

- インスタンスストレージの使用率がノードあたり70%に達したらノードを追加する

- 時系列データなどは`単一タイムスタンプ`ごとに1行とする縦長のテーブルに格納する

- コストを抑えてパフォーマンスを上げるには`テーブルの行スペース全体に読み取り/書き取りを均等に分散`するようにスキーマを(再)定義する

## スキーマのベストプラクティス
- テーブル
    - 似たスキーマを持つデータセットは同じテーブルに保存
    - 小さなテーブルを多数作成しない

- 列ファミリー
    - 関連する列は同じ列ファミリーに
    - 1つのテーブルに100個まで
    - データ保持ニーズが異なる列は別の列ファミリーに

- 列
    - 列修飾子をデータとして扱う(短くて意味があるやつ)
    - 必要な数だけ列を作成
    - 1行に列は多すぎないようにする

- 行
    - 1行に100MBを超えるデータを保存しない
    - すべての情報を1行に保存する
    - 関連するエンティティは隣接する行に保存

- セル
    - 1つのセルは10MBを超えないようにする
    - 例外として行サイズが数百MBの時は複数行に分ける

- 行キー
    - 行キーは短く
    - データ取得に使用するクエリに基づいて設計
    - 複数の区切られた値は各行キーに保存
    - 人が読める形式の文字列を使う
    - 適切に定義された行範囲を取得できる行キーを作成する